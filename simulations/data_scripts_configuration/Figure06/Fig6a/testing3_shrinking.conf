# ***************************************************************************
# *
# *  Copyright (C) 2013-2016 University of Dundee
# *  All rights reserved.
# *
# *  This file is part of SAMoS (Soft Active Matter on Surfaces) program.
# *
# *  SAMoS is free software; you can redistribute it and/or modify
# *  it under the terms of the GNU General Public License as published by
# *  the Free Software Foundation; either version 2 of the License, or
# *  (at your option) any later version.
# *
# *  SAMoS is distributed in the hope that it will be useful,
# *  but WITHOUT ANY WARRANTY; without even the implied warranty of
# *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# *  GNU General Public License for more details.
# *
# *  You should have received a copy of the GNU General Public License
# *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# *
# *****************************************************************************

# This configuration file is used to produce Figure 6a in the main paper.

# All runtime messages will be sent to file messages.msg
messages messages.msg

# Meta-data will be sent to a file configuration.json (JSON format)
config configuration {type = json}

# box is cubic with size 100x100x10 
box fixed { lx = 100.0;  ly = 100.0;  lz = 10.0 }

# We read in cell positions 
input epi_testing.input

# Read boundary connectivity information
read_cell_boundary epi_testing.boundary

# Set neighbour list paramters for tissue simulations (please see SAMoS documentation for details)  
nlist { rcut = 2.4; pad = 0.5; build_faces; max_perimeter = 30.0; max_edge_len = 20.0; triangulation; }

# All cells are constrained to move in the xy plane without any other constraints on their position
constraint plane { unlimited  }

# Use the AVM cell potential to model this system
# K is the area modulus
# gamma is the perimeter modulus 
# lambda is the junction tension
pair_potential vp { K = 1.0; gamma = 1.0; lambda = -4.40 }


# line tension only applies to the particles that are on the boundary
# In this specific case line tension is set to 0 and the native distance between neighbouring boundary sites is also set to 0.
pair_potential line_tension { lambda = 0.0; l0 = 0.0 }

# Bending penalty of the bourady line is set to 0.5
pair_potential boundary_bending { kappa = 0.5; }

# Soft repulsion between cell centers is used to prevent them to getting too close to each other   
# We set the stiffness to 10.0 and the potential range to 0.5
pair_potential soft { k = 10.0; a = 0.5 }


# frequent logging of simple metrics
log cell.log { freq = 100; size; area; avg_perim; vp_energy }

# .vtp dumps for visualisation with Paraview
# for the positions of cell centres
dump cell { type=vtp; start=0; freq=100; multi; include_mesh }
#Â and the dual lattice (actual cells)
dump cell_dual { type=vtp; start=0; freq=100; multi; dual }

# text dumps for data analysis
dump cell { type=full; start=0; freq=100; multi; id; tp; boundary; coordinate; velocity; force; director; area; cell_area; cell_perim; keys }
# faces files can be used to reconstruct the triangulation and the mesh in python for analysis.
dump faces { type=face; start=0; freq=100; multi; }


# IMPORTANT. Adding the activity to the non-boundary particles only. 
external self_propulsion { alpha = 0.1; exclude_boundary; } 

# Running the simulation

# We set the simulation time step to 0.025
timestep 0.025

# Old syntax
# IMPORTANT. v0 is set to 0. in the integrator. We use 'external self_propulsion {}' command to add activity.
integrator brownian {group = all; seed = 1;  nu = 0.01; mu = 1.0; v0 = 0 }

# New syntax 
# For new syntax uncomment both 'integrator' lines below and comment out the above 'integrator' line.
# use the brownian integrator for particle posiion 
#integrator brownian_pos {group = all; seed = 1; mu = 1.0 }
# and use Brownian dynamics for cell polarity with rotational noise 0.01
#integrator brownian_align { seed = 0; nu = 0.01;  }

# run the simulation for 25000 steps
run 25000



